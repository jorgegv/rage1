#!/usr/bin/perl

################################################################################
##
## RAGE1 - Retro Adventure Game Engine, release 1
## (c) Copyright 2020 Jorge Gonzalez Villalonga <jorgegv@daikon.es>
## 
## This code is published under a GNU GPL license version 3 or later.  See
## LICENSE file in the distribution for details.
## 
################################################################################

use warnings;
use strict;
use utf8;

use Data::Dumper;
use Getopt::Std;

my $c_file = 'flow_data.c';
my $h_file = 'flow_data.h';
my $output_fh;

# dump file for internal state
my $dump_file = 'datagen_internal.dmp';

my $all_state;

sub load_internal_state {
    open DUMP, $dump_file or
        die "Could not open $dump_file for reading\n";
    local $/ = undef;
    $all_state = eval <DUMP>;
    close DUMP;
}

##########################################
## Input data parsing and state machine
##########################################

sub read_input_data {
    # possible states: NONE, RULE
    # initial state
    my $state = 'NONE';
    my $cur_rule = undef;

    # read and process input
    my $num_line = 0;
    while (my $line = <>) {

        $num_line++;

        # cleanup the line
        chomp $line;
        $line =~ s/^\s*//g;		# remove leading blanks
        $line =~ s/\s*$//g;		# remove trailing blanks
        $line =~ s/\/\/.*$//g;		# remove comments (//...)
        next if $line eq '';		# ignore blank lines

        # process the line
        if ( $state eq 'NONE' ) {
            if ( $line =~ /^BEGIN_RULE$/ ) {
                $state = 'RULE';
                next;
            }
            die "Syntax error:line $num_line: '$line' not recognized (global section)\n";

        } elsif ( $state eq 'RULE' ) {

            if ( $line =~ /^SCREEN\s+(\w+)$/ ) {
                next;
            }
            if ( $line =~ /^END_RULE$/ ) {
                $state = 'NONE';
                next;
            }
            die "Syntax error:line $num_line: '$line' not recognized (RULE section)\n";

        } else {
            die "Unknown state '$state'\n";
        }
    }
}

#############################
## General Output Functions
#############################

sub output_header {
    print $output_fh <<EOF_HEADER
///////////////////////////////////////////////////////////
//
// Game data - automatically generated with flowgen.pl
//
///////////////////////////////////////////////////////////

#include <arch/spectrum.h>

#include "map.h"
#include "sprite.h"
#include "game_data.h"
#include "debug.h"
#include "hero.h"
#include "game_state.h"
#include "bullet.h"
#include "game_config.h"

EOF_HEADER
;
}

sub output_header_file {
    print $output_fh <<GAME_DATA_H_1
#ifndef _GAME_DATA_H
#define _GAME_DATA_H

#include <stdint.h>
#include <games/sp1.h>

// global map data structure - autogenerated by datagen tool into
// game_data.c
extern uint8_t map_num_screens;
extern struct map_screen_s map[];

// global items table
extern uint8_t inventory_max_items;
extern struct item_info_s all_items[];

// a pre-filled hero_info_s struct for game reset
// generated by datagen.pl in game_data.c
extern struct hero_info_s hero_startup_data;
extern struct sp1_ss *hero_sprite;

void init_screen_sprite_tables(void);
void init_hero_sprites(void);
void init_bullet_sprites(void);

// auxiliary pointers
GAME_DATA_H_1
;

    print $output_fh "\n#endif // _GAME_DATA_H\n";


}

# this function is called from main
sub output_generated_data {
    # output .c file
    open( $output_fh, ">", $c_file ) or
        die "Could not open $c_file for writing\n";

    output_header;

    close $output_fh;

    # output .h file
    open( $output_fh, ">", $h_file ) or
        die "Could not open $h_file for writing\n";

    output_header_file;

    close $output_fh;

}

# creates a dump of internal data so that other tools (e.g.  FLOWGEN) can
# load it and use the parsed data. Use "-c" option to dump the internal data
sub dump_internal_data {
    open DUMP, ">$dump_file" or
        die "Could not open $dump_file for writing\n";

    print DUMP Dumper( $all_state );
    close DUMP;
}

#########################
## Main loop
#########################

our ( $opt_d, $opt_c );
getopts("d:c");
if ( defined( $opt_d ) ) {
    $c_file = "$opt_d/$c_file";
    $h_file = "$opt_d/$h_file";
    $dump_file = "$opt_d/$dump_file";
}

# load internal state from previous tools
load_internal_state;

# read, validate and compile input
read_input_data;

# run consistency checks
#run_consistency_checks;

# generate output
#output_generated_data;

# dump internal data if required to do so
#dump_internal_data
#    if ( $opt_c );
