# BANKED FUNCTIONS

There is the need to make more room in low memory (below 0xC000) for always
accessible game assets, and so some engine code needs to be stored and run
from the extra memory banks.

The extra game data assets are stored compressed in DATASETs; the extra user
game functions are stored in CODESETs; and finally the internal game
functions stored in extra memory banks are called BANKED code.

The mechanism for running functions in CODESETs and BANKED code is very
similar, but the setup is quite simpler for the BANKED code, since all the
configuration is static wih each RAGE1 release (in opposition to the CODESET
game code, which varies from game to game).

## Design

- Each banked function is assigned a global unique ID (starting at 0)

- There is a reserved memory bank for engine BANKED code (bank 4,
  uncontended, for performance reasons)

- As usual, the memory bank is mapped at address 0xC000

- The first data structure of the BANKED code bank is an array of pointers
  to the banked functions which live on the bank. It is located at address
  0xC000 (known address), so it is easily acessible from lowmem

- A function call to a given BANKED function is done by indexing the
  function ID (known at compile time) in the banked functions array (always
  at address 0xC000)

- BANKED functions can use prototypes `void f(void)` or `void f( uint16_t
  arg )`

- All accesses from the BANKED functions to lowmem data must be done via the
  macro definitions in `banked.h`

- Main symbols in low memory can be accessed from banked code by means of a
  `struct main_shared_data_s` which is populated at program start by
  function `init_banked_code()`.  This structure contains pointers to useful
  data in low memory, such as the `game_state` structure, the tile type data
  structure and others (see `banked.h` file for the structure definition). 
  Macros are defined in `banked.h` for accessing those data easily when
  compiling banked code.

- Initially, banked functions receive no parameters and return nothing, but
  this limitation is to be revisited, since it seems easy to have a
  structure in low memory for passing parameters and return values to the
  BANKED functions at runtime

**Implementation NOTES:**

- Compilation order: datasets - codesets - main (->main.map) - symbol macro
  definitions -> rest of 128K build

- For compiling main.bin, dataset_info and codeset_info data structs are
  needed -> they are generated by BANKTOOL -> we need to split BANKTOOL
  functionality in 2:

  - Dataset and Codeset layout: outputs dataset_info and codeset_info
    structs and generates dataset and codeset bank binaries

  - Bank BASIC loader: searches for bank binaries and outputs a BASIC
    loader

  - The BANKED code bank binary is output separately in the Makefile, but it
    is added to the same directory as the previous dataset and codeset
    banks, so that it is found by the BASIC loasder generator

## Recommendations

When migrating engine functions to be banked functions, the following points
should be taken into account:

- Take care to check that the data accessed from the function is either
  inside the bank, or in low memory

- Take care with pointers passed from low memory code to banked code: some
  of those pointers may point to data above 0xC000 and thus will be
  unavailable when the banked function is run.

- Use `make mem` to ensure that no data section is above 0xC000

## Steps for migration of an engine function to banked code

- Function signatures are constructed as follows:

  - a16 (for argument, 16-bit), r8 (for return, 8-bit), etc.
  - Return qualifier always comes last, arguments come first
  - If no arguments are used, no aNN signature should be used
  - If no return value no rNN should be used
  - A function matching the protype `void f( void )` has no signature
  - Example: `a16_a16_r8` is a signature for a function with the following
    prototype: `uint8_t f( uint16_t arg1, uint16_t arg2 )`

- The signature of the function to migrate (args plus return value) must
  have an associated `memory_banked_function_call...()` function (see
  `memory.h` for instructions on how to define them)

- A valid function `typedef` must also exist in `memory.h` for the given
  function signature.

- The function to migrate should match any of the prototypes defined by the
  signature `typedef`s.

- Copy the source file which contains the function to be migrated to the
  `banked_code` directory

- All banked code source files should `#include "rage1/banked.h`, and it
  should be included after all needed additional RAGE1 include files have
  been included.  The `banked.h` file should be the last one of the RAGE1
  `#includes`

- Add the function definition to the config file `etc/rage1-config.yml`,
  under the `banked_functions` key (see existing functions):

  - The `name` parameter is mandatory, it is the name of the C function
    being migrated
  - The `signature` parameter is only needed if the function does not match
    the `void f( void )` prototype. Signature definition must be according
    to the rules indicated above.
  - The `build_dependency` parameter specifies a BUILD_FEATURE_xx macro that
    must be found in `features.h` if the function definitions are to be
    generated. If no dependency is declared, function definitions are always
    generated

- Directories under `engine/banked_code`:

  - `common`: code in this folder will be compiled as banked code in 128K
    mode, and will be included also when compiling in 48K mode
  - `128`: code in this folder will only be compiled as banked code in 128K
    mode, and it will _not_ be included in the 48K build

- When moving a function from the regular build to the `banked_code` zone,
  the main function will normally go into the `common` folder, so that the
  function is compiled and included in both 48K and 128K builds.

- If some support functions are needed for the main banked function but they
  also need to be called from low memory code, a copy of those functions
  shall be included in the `128` folder, so that:

  - When building in 128K mode, 2 copies of the support functions will be
    included, one in low memory (`engine/src`) and one in banked code
    (`engine/banked_code/128`).  The code compiled in each area will call
    the support function included in its compilation unit.

  - When building in 48K mode, only the copy from `engine/src` will be
    compiled and used, so only 1 copy of the function will exist.

- This situation normally happens only temporarily when migrating some
  functions from a given module (e.g.  `enemy.c`) but not others: not all
  functions from a module need to be migrated initially.  When/if later on,
  _all_ of the module functions are migrated to `banked_code`, the support
  functions under `banked_code/128` directory can be moved to
  `banked_code/common`, so that they are always compiled as banked code in
  128K mode and as low memory in 48K mode.

## Calling Banked Functions from an ISR

Banked functions can be called from Interrupt Service Routines without
problems.  They just need to be called using the regular `memory.h` macros
for them so that correct bank switching is done.

Since the bank port is write only, we cannot read the current bank state, so
we need to keep it in a dedicated variable, and update that variable each
time a bank switch is done.

It is critical that both the bank switch and the update of the variable is
done atomically: if an interrupt is received just between switching bank and
updating the bank variable, and then a bank switch is done again in the ISR
routine (e.g.  because the ISR calls banked code), the state between the
variable and the banking register will not match and a crash will occur
shortly afterwards.

This happens in RAGE1 when using interrupt-driven music playback with the
tracker, since the tracker code is compiled to banked memory and thus needs
a bank switch when the periodic task is called for playing music.

The way to make the changes atomic is by enclosing the bank switch between
an DI/EI instruction pair.  When this is done, the following cases may
occur:

a) INT happens in the middle of regular code (bank 0).  The banked code in
the ISR is called normally: the ISR will do the bank switch, run the banked
code and restore the previous bank.  The bank-switching function will
restore interrupts (EI) early during the ISR and not at the end, but this is
not harmful because the Refresh INT is the only interrupt source, and a new
int will not happen if we ensure absolutely that the whole ISR runs in less
than 1/50 s.  This will happen anyway, because if it is longer, we are
already screwed.

b) INT happens in the middle of banked code (bank not 0).  Again, same
reasoning as above, plus bank switch/restore inside the ISR is done
correctly because the banked call routines are fully reentrant: they store
the previous bank state in the stack, so everything is restored correctly
when returning from the ISR.
