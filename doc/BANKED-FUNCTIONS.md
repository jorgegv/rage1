# BANKED FUNCTIONS

There is the need to make more room in low memory (below 0xC000) for always
accessible game assets, and so some engine code needs to be stored and run
from the extra memory banks.

The extra game data assets are stored compressed in DATASETs; the extra user
game functions are stored in CODESETs; and finally the internal game
functions stored in extra memory banks are called BANKED code.

The mechanism for running functions in CODESETs and BANKED code is very
similar, but the setup is quite simpler for the BANKED code, since all the
configuration is static wih each RAGE1 release (in opposition to the CODESET
game code, which varies from game to game).

## Design

- Each banked function is assigned a global unique ID (starting at 0)

- There is a reserved memory bank for engine BANKED code (bank 4,
  uncontended, for performance reasons)

- As usual, the memory bank is mapped at address 0xC000

- The first data structure of the BANKED code bank is an array of pointers
  to the banked functions which live on the bank. It is located at address
  0xC000 (known address), so it is easily acessible from lowmem

- A function call to a given BANKED function is done by indexing the
  function ID (known at compile time) in the banked functions array (always
  at address 0xC000)

- All BANKED functions must use the prototype `void f(void)`

- All accesses from the BANKED functions to lowmem data must be done via the
  macro definitions in `banked.h`

- The `banked.h` file will include a generated file called `mainsyms.h`
  which is generated from the `main.map` file which is created whe compiling
  the main program.  This file maps the symbols in `main` to their final
  addresses in low memory, so that the banked functions can use them.

- Initially, banked functions receive no parameters and return nothing, but
  this limitation is to be revisited, since it seems easy to have a
  structure in low memory for passing parameters and return values to the
  BANKED functions at runtime

**Implementation NOTES:**

- Compilation order: datasets - codesets - main (->main.map) - symbol macro
  definitions -> rest of 128K build

- For compiling main.bin, dataset_info and codeset_info data structs are
  needed -> they are generated by BANKTOOL -> we need to split BANKTOOL
  functionality in 2:

  - Dataset and Codeset layout: outputs dataset_info and codeset_info
    structs and generates dataset and codeset bank binaries

  - Bank BASIC loader: searches for bank binaries and outputs a BASIC
    loader

  - The BANKED code bank binary is output separately in the Makefile, but it
    is added to the same directory as the previous dataset and codeset
    banks, so that it is found by the BASIC loasder generator

## Recommendations

When migrating engine functions to be banked functions, the following points
should be taken into account:

- Take care to check that the data accessed from the function is either
  inside the bank, or in low memory

- Take care with pointers passed from low memory code to banked code: some
  of those pointers may point to data above 0xC000 and thus will be
  unavailable when the banked function is run.

- Use `make mem` to ensure that no data section is above 0xC000

## Steps for migration of an engine function to banked code

- The function to migrate should match the `void f( void )` prototype

- Copy the source file which contains the function to be migrated to the
  `banked_code` directory

- All banked code source files should `#include "rage1/banked.h`, and it
  should be included after all needed additional RAGE1 include files have
  been included.  The `banked.h` file should be the last one of the RAGE1
  `#includes`

- Add function ID and function call macro (for 128K mode) to `memory.h`

- Add the function ID to the banked function table at `00main.asm` in
  `banked_code`

- Add the needed macro definitions to `banked.h` for the low memory symbols
  and data structures that the migrated function will access

- Directories under `engine/banked_code`:
  - `common`: code in this folder will be compiled as banked code in 128K
    mode, and will be included also when compiling in 48K mode
  - `128`: code in this folder will only be compiled as banked code in 128K
    mode, and it will _not_ be included in the 48K build

- When moving a function from the regular build to the `banked_code` zone,
  the main function will normally go into the `common` folder, so that the
  function is compiled and included in both 48K and 128K builds.

- If some support functions are needed for the main banked function but they
  also need to be called from low memory code, a copy of those functions
  shall be included in the `128` folder, so that:

  - When building in 128K mode, 2 copies of the support functions will be
    included, one in low memory (`engine/src`) and one in banked code
    (`engine/banked_code/128`).  The code compiled in each area will call
    the support function included in its compilation unit.

  - When building in 48K mode, only the copy from `engine/src` will be
    compiled and used, so only 1 copy of the function will exist.

- This situation happens when migrating some functions from a given module
  (e.g.  `enemy.c`) but not others: not all functions from a module need to
  be migrated initially.  When/if later on, _all_ of the module functions
  are migrated to `banked_code`, the support functions under
  `banked_code/128` directory can be moved to `banked_code/common`, so that
  they are always compiled as banked code in 128K mode and as low memory in
  48K mode.
